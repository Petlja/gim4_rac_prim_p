Алгоритам RSA - за оне који желе да знају више
===============================================

Овде ће бити објашњен и изложен поступак прављења јавног и тајног кључа за алгоритам RSA, као и сâм 
алгоритам којим се поруке криптују и декриптују помоћу тих кључева. Из тога ће се видети зашто (тј. 
под којим условима) је овај систем безбедан, односно зашто нападач не може да открије приватни кључ 
и тиме разбије шифру.

Уколико вас не интересују детаљи алгоритма RSA, можете да наставите читање од следеће стране. Тиме 
нећете пропустити ништа што је важно за разумевање даљег текста.

|

Алгоритам RSA се базира, са једне стране на резултатима из теорије бројева, а са друге на рачунској 
сложености одређених поступака, као што је растављање броја на просте чиниоце (факторизација броја).

Прво ћемо описати како се поступак примењује. 

Генерисање криптографских кључева за RSA алгоритам
''''''''''''''''''''''''''''''''''''''''''''''''''

Први корак при генерисању кључева је избор два велика проста броја, :math:`p` и :math:`q`. Нека је 
:math:`n=p*q`. Да бисмо формирали кључ за енкрипцију, потребан нам је још број :math:`e`, такав да је 
:math:`1 < e < (p-1)(q-1)` и да је :math:`e` узајамно прост са :math:`(p-1)(q-1)`.

.. infonote::

    Јавни кључ представља пар бројева :math:`(n, e)` и он може да буде доступан свима.

Може се доказати да за дате :math:`p, q, e` који испуњавају наведене услове, постоји јединствен број 
:math:`d`, такав да је :math:`1 < d < (p-1)(q-1)` и да :math:`d \cdot e` при дељењу са :math:`(p-1)(q-1)` 
даје остатак :math:`1`, што записујемо 

.. math::

    d \cdot e \equiv_{(p-1)(q-1)} 1

Кажемо и да је :math:`d \cdot e` једнако јединици по модулу :math:`(p-1)(q-1)`, односно да је број 
:math:`d` мултипликативни инверз од :math:`e` по модулу :math:`(p-1)(q-1)`. 

.. infonote::

    Приватни кључ представља пар бројева :math:`(n, d)` и он треба да буде познат само примаоцу порука.

Пример генерисања јавног и приватног RSA кључа
''''''''''''''''''''''''''''''''''''''''''''''

Нека је :math:`p=11, q=13`. Према томе, :math:`n = p \cdot q = 11 \cdot 13 = 143`. Изаберимо нпр. 
:math:`e=7`. Ово је један исправан избор, јер број :math:`7` нема заједничких фактора (осим јединице) 
са :math:`(p − 1)(q − 1) = 10 \cdot 12 = 120`, тј. јер је :math:`nzd(7, 120) = 1`.

Пар бројева :math:`(n, e) = (143, 7)` представља јавни кључ, који можемо да објавимо и учинимо 
доступним свима од којих намеравамо да примамо криптоване поруке.

Помоћу `проширеног Еуклидовог алгоритма <https://sr.wikipedia.org/wiki/Проширени_Еуклидов_алгоритам>`_, 
за :math:`p = 11, q = 13, e = 7` добијамо :math:`d = 103`. Проверимо да је :math:`d` исправно израчунато, 
тако што потврдимо да је :math:`d \cdot e \equiv_{(p-1)(q-1)} 1`:

У нашем случају, :math:`d \cdot e = 103 \cdot 7 = 721 \equiv_{120} 1`.

Следећи програм за изабране :math:`p, q, e` израчунава :math:`d`. Можете да га испробате на
вредностима из примера, или на вредностима које изаберете (промените прва два реда програма).

.. activecode:: rsa_javni_i_privatni_kljuc

    p, q = 11, 13 # параметри алгоритма
    e = 7
    n = p*q
    print('Јавни кључ је', (n, e))

    # функција за дате a, b враћа d, x, y, такве да је ax+by = nzd(a,b)
    def prosireni_euklidov_algoritam(a, b):
        if (a == 0):
            d, x, y = b, 0, 1
        else:
            d, x1, y1 = prosireni_euklidov_algoritam(b % a, a)
            x, y = y1 - (b // a) * x1, x1

        return d, x, y
 
    # мултипликативни инверз од `a` по модулу `m`
    # (ради ако су `a` и `m` узајамно прости)
    def inverz(a, m):
        gcd, x, y = prosireni_euklidov_algoritam(a, m)
        # следећа наредба служи да би се добило 0 < x < m
        x = (x % m + m) % m 
        return x
 
    d = inverz(e, (p-1)*(q-1))
    print('Приватни кључ је', (n, d))

 
Криптовање и декриптовање
'''''''''''''''''''''''''

Једном када је пар кључева генерисан, процес шифровања и дешифровања је релативно једноставан и 
није рачунски захтеван.

Претпоставимо да пошиљалац жели да пошаље текстуалну поруку користећи јавни кључ :math:`(n, e)`.
Пошиљалац прво треба да представи текст као низ бројева мањих од :math:`n`. Поступак кодирања 
текста помоћу бројева може такође да буде јавно познат (ово још увек није шифровање, односно 
енкрипција). Након добијања поменутог низа бројева који представља полазни текст, сваки од тих 
бројева криптујемо помоћу кључа :math:`(n, e)` и декриптујемо помоћу кључа :math:`(n, d)`, на 
следећи начин.

**Криптовање:** Нека је :math:`M` један од бројева из низа који представља полазни текст. Криптована 
вредност :math:`C = F(M)` добија се као :math:`C = M^e \mod n`. У нашем примеру, ако је :math:`M=46`, 
добијамо криптовану вредност :math:`C = 46^7 \mod 143 = 84`

**Декриптовање:** Процес декриптовања је једнако једноставан као и криптовање. Претпоставимо да смо 
примили криптовани број :math:`C`. Полазни број :math:`M = F^{-1}(C)` добијамо као :math:`C^d \mod n`.
У нашем примеру, :math:`C^d \mod n = 84^{103} \mod 143 = 46`.

Следећи програм илуструје рад алгоритма RSA.

.. activecode:: rsa_program
    :include: rsa_javni_i_privatni_kljuc

    def kriptovano(M):
        return (M**e) % n

    def dekriptovano(C):
        return (C**d) % n

    M = 46
    C = kriptovano(M)
    M1 = dekriptovano(C)

    print('Порука  M =', M)
    print('Криптована вредност C =', C)
    print('Декриптована вредност M =', M1)



Напади на RSA криптосистем
''''''''''''''''''''''''''

Нападач би могао да покуша да на основу јавног кључа открије, тј. израчуна тајни кључ и тако 
разбије шифру. Пошто је број :math:`n` део јавног кључа, он је нападачу познат. Растављањем 
броја :math:`n` на просте чиниоце, нападач може да дође до простих бројева :math:`p` и :math:`q`,
а затим да одреди кључ :math:`d` на исти начин као што то ради и власник приватног кључа.

Ево како би тај постуапак изгледао:

.. activecode:: rsa_razbijanje

    def faktorizacija(n):
        faktori = []
        i = 2
        while i*i <= n:
            if n % i == 0:
                faktori.append(i)
                n = n // i
            else:
                i += 1

        if n > 1:
            faktori.append(n)

        return faktori
        
    # функција за дате a, b враћа d, x, y, такве да је ax+by = nzd(a,b)
    def prosireni_euklidov_algoritam(a, b):
        if (a == 0):
            d, x, y = b, 0, 1
        else:
            d, x1, y1 = prosireni_euklidov_algoritam(b % a, a)
            x, y = y1 - (b // a) * x1, x1

        return d, x, y
 
    # мултипликативни инверз од `a` по модулу `m`
    # (ради ако су `a` и `m` узајамно прости)
    def inverz(a, m):
        gcd, x, y = prosireni_euklidov_algoritam(a, m)
        # следећа наредба служи да би се добило 0 < x < m
        x = (x % m + m) % m 
        return x
 
    def kriptovano(M):
        return (M**e) % n

    def dekriptovano(C):
        return (C**d) % n

    n = 143
    e = 7
    C = 84
    faktori = faktorizacija(n)
    if len(faktori) == 2:
        p, q = faktori
        d = inverz(e, (p-1)*(q-1))

    M = dekriptovano(C)
    print('Декриптована вредност M =', M)

.. infonote::

    Видимо да полазећи само од јавног кључа :math:`(n, e)`, нападач **у принципу** може да израчуна 
    приватни кључ :math:`(n, d)`. Након откривања приватног кључа, нападач веома једноставно може да 
    декриптује сваки пресретнути шифрат :math:`C` и открије поруку :math:`M`.

Сва безбедност криптосистема RSA је у томе што се у пракси користе много већи бројеви од ових у 
нашем примеру. Мали бројеви попут ових из примера би учинили криптосистем са таквим параметрима врло 
небезбедним. Ми смо користили мале бројеве само ради лакшег праћења рада алгоритма и његовог разумевања.

Функције ``prosireni_euklidov_algoritam``, ``inverz``, ``kriptovano`` и ``dekriptovano`` се извршавају 
прилично брзо чак и за огромне бројеве, у њима је број потребних операција сразмеран броју цифара броја 
на који се примењују. Једина спорија функција је ``faktorizacija``, јер је број операција које су њој потребне сразмеран са вредношћу :math:`\sqrt{n}`. Када би нападач користио поступак факторизације као у 
претходном програму, за број :math:`n` од 100 цифара би му на обичном рачунару требале милијарде година да 
нађе његове просте чиниоце. 

.. infonote::

    Безбедност алгоритма RSA се не заснива на пажљивом чувању неког тајног податка или поступка. 
    Напротив, видели смо да је познато како може да се израчуна приватни кључ. Дакле, изазов који се 
    поставља пред нападача је „само“ проблем огромне количине рачунања. 

Током ових неколико деценија колико се алгоритам RSA користи, пронађени су разни начини да се алгоритам 
факторизације убрза. Због тога, чак ни бројеви са 100 цифара нису више довољно велики да би се 
криптовање базирано на њима сматрало безбедним. То не компромитује саму идеју алгоритма, али захтева 
од организатора криптосистема да користе све веће и веће бројеве. Да би се по данашњим стандардима 
поступак криптовања сматрао безбедним, потребно је да се бројеви :math:`p` и :math:`q` записују са 
по бар 1024 бита, што значи да имају преко 300 декадних цифара. При томе, ово чак није једини услов који 
треба да испуне :math:`p` и :math:`q`, да би нападачу било тешко (у пракси немогуће) да разбије шифру. 
Неки од додатних услова су да бројеви :math:`p` и :math:`q` не смеју да буду сувише близу један другом 
(треба да се по дужини записа разликују за више десетина цифара), а важно је и да се ниједан од бројева 
:math:`p` и :math:`q` не користи у другим криптосистемима заснованим на алгоритму RSA. 

Последњи услов може лако да се образложи. Претпоставимо да смо изабрали неке огромне просте бројеве 
:math:`p_1` и :math:`q_1`, а неко други бројеве :math:`p_2` и :math:`q_2`. Ако би било :math:`p_1 = p_2`, 
тада би нападач, знајући бројеве :math:`n_1` и :math:`n_2`, могао брзо да нађе :math:`nzd(n_1, n_2) = p_1 = p_2`, 
а то би му било довољно да факторише и :math:`n_1` и :math:`n_2` и да разбије обе шифре.

~~~~

Видимо да је избор простих бројева који се користе у алгоритму RSA прилично сложен проблем. Исто важи 
и за избор јавног кључа, па и за начин представљања оригиналних података бројевима, који ће даље бити 
криптовани алгоритмом RSA. На ову тему постоји велики број научних радова, што није ни чудо због изузетног 
практичног значаја који овај алгоритам и даље има. Из свега што је познато о алгоритму RSA, може се 
закључити да је овај поступак криптовања у основи поуздан, али да је у многим случајевима имплементиран 
на несигуран начин, тј. са недовољно поузданим вредностима параметара.

Мада је алгоритам RSA у међувремену инспирисао откриће других, сличних али напреднијих алгоритама, 
он је још увек најпопуларнији криптосистем са јавним кључем.
