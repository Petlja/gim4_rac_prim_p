Криптовање помоћу јавног кључа
==============================

Природно, први криптосистеми су држали у тајности и сам поступак криптовања и кључ за енкрипцију и 
декрипцију. Такви системи су подразумевали да само пошиљалац и прималац поруке знају и поступак 
енкрипције и декрипције, тј. функцију :math:`F`, и кључ који се тренутно користи. Овакве системе 
називамо системима са тајним кључем. Ако се за енкрипцију и декрипцију користи исти кључ, систем 
је симетричан.

Почетни кључ је могао да буде договорен раније, пре него што се пошиљалац и прималац раздвоје. Као 
што смо поменули, потенцијални проблем код оваквих криптосистема је што може да буде тешко да се 
нови кључ касније достави на безбедан начин. Ипак, овакви системи су дуго коришћени са доста успеха.
Познат је и обрнути пример из другог светског рата, када је британска обавештајна служба открила 
систем који су Немци користили за криптовање порука. Након откривања шифре, Британци су успешно 
пресретали и кључеве коришћене у каснијој комуникацији.

Овакви системи због своје природе нису били погодни за масовну упротребу, јер са повећавањем броја 
корисника било би практично немогуће очувати тајност поступка. Да би неки криптосистем могао да се 
користи масовно, било је потребно да се осмисли такав начин криптовања у коме сам поступак, па ни 
кључ за криптовање не би морао да буде тајан (свако може да шаље поруке). Одавде следи да за 
криптовање и декриптовање морају да се користе различити кључеви. Дакле, трагало се за криптосистемом 
са следећим особинама:

- постоје два различита кључа, један за криптовање, а други за декриптовање
- поступак криптовања/декриптовања и кључ за криптовање су јавно доступни
- кључ за декриптовање се чува у тајности и познат је само примаоцу порука
- поступак генерисања кључева треба да буде рачунски јефтин (да рачунар може брзо да га обави)
- поступак криптовања и декриптовања такође треба да буде рачунски јефтин
- поступак разбијања шифре (израчунавања кључа за декрипцију) треба да буде рачунски веома скуп, 
  тако да је рачунару за то потребно огромно време.

Један систем са овим особинама је осмишљен 1977. године, а у наредним деценијама је постао веома 
познат и масовно коришћен. Реч је о чувеном алгоритму RSA, који је добио име по иницијалима својих 
аутора (RSA - Rivest, Shamir, Adleman).

Алгоритам RSA
-------------

Алгоритам RSA се базира са једне стране на резултатима из теорије бројева, а са друге на рачунској 
сложености одређених поступака, као што је растављање број на просте чиниоце (факторизација броја).

Прво ћемо описати како се поступак примењује. 

Генерисање криптографских кључева за RSA алгоритам
''''''''''''''''''''''''''''''''''''''''''''''''''

Први корак при генерисању кључева је избор два велика проста броја, :math:`p` и :math:`q`. Нека је 
:math:`n=p*q`. Да бисмо формирали кључ за енкрипцију, поребан нам је још број :math:`e`, такав да је 
:math:`1 < e < (p-1)(q-1)` и да је :math:`e` узајамно прост са :math:`(p-1)(q-1)`.

.. infonote::

    Јавни кључ представља пар бројева :math:`(n, e)` и он може да буде доступан свима.

Може се доказати да за дате :math:`p, q, e` који испуњавају наведене услове, постоји јединствен број 
:math:`d`, такав да је :math:`1 < d < (p-1)(q-1)` и да :math:`d \cdot e` при дељењу са :math:`(p-1)(q-1)` 
даје остатак :math:`1`, што записујемо 

.. math::

    d \cdot e \equiv_{(p-1)(q-1)} 1

Кажемо и да је :math:`d \cdot e` једнако јединици по модулу :math:`(p-1)(q-1)`, односно да је број 
:math:`d` мултипликативни инверз од :math:`e` по модулу :math:`(p-1)(q-1)`. 

.. infonote::

    Приватни кључ представља пар бројева :math:`(n, d)` и он треба да буде познат само примаоцу порука.

Пример генерисања јавног и приватног RSA кључа
''''''''''''''''''''''''''''''''''''''''''''''

Нека је :math:`p=11, q=13`. Према томе, :math:`n = p \cdot q = 11 \cdot 13 = 143`. Изаберимо нпр. 
:math:`e=7`. Ово је један исправан избор, јер број :math:`7` нема заједничких фактора (осим јединице) 
са :math:`(p − 1)(q − 1) = 10 \cdot 12 = 120`, тј. јер је :math:`nzd(7, 120) = 1`.

Пар бројева :math:`(n, e) = (143, 7)` представља јавни кључ, који можемо да објавимо и учинимо 
доступним свима од којих намеравамо да примамо криптоване поруке.

Помоћу проширеног Еуклидовог алгоритма, за :math:`p = 11, q = 13, e = 7` добијамо :math:`d = 103`.
Проверимо да је :math:`d` исправно израчунато, тако што потврдимо да је 
:math:`d \cdot e \equiv_{(p-1)(q-1)} 1`:

У нашем случају, :math:`d \cdot e = 103 \cdot 7 = 721 \equiv_{120} 1`.

Следећи програм за изабране :math:`p, q, e` израчунава :math:`d`. Можете да га испробате на
вредностима из примера, или на вредностима које изаберете (промените прва два реда програма).

.. activecode:: rsa_javni_i_privatni_kljuc

    p, q = 11, 13 # параметри алгоритма
    e = 7
    n = p*q
    print('Јавни кључ је', (n, e))

    # функција за дате a, b враћа d, x, y, такве да је ax+by = nzd(a,b)
    def prosireni_euklidov_algoritam(a, b):
        if (a == 0):
            d, x, y = b, 0, 1
        else:
            d, x1, y1 = prosireni_euklidov_algoritam(b % a, a)
            x, y = y1 - (b // a) * x1, x1

        return d, x, y
 
    # мултипликативни инверз од `a` по модулу `m`
    # (ради ако су `a` и `m` узајамно прости)
    def inverz(a, m):
        gcd, x, y = prosireni_euklidov_algoritam(a, m)
        # следећа наредба служи да би се добило 0 < x < m
        x = (x % m + m) % m 
        return x
 
    d = inverz(e, (p-1)*(q-1))
    print('Приватни кључ је', (n, d))

 
Криптовање и декриптовање
'''''''''''''''''''''''''

Једном када је пар кључева генерисан, процес шифровања и дешифровања је релативно једноставан и 
није рачунски захтеван.

Претпоставимо да пошиљалац жели да пошаље текстуалну поруку користећи јавни кључ :math:`(n, e)`.
Пошиљалац прво треба да представи текст као низ бројева мањих од :math:`n`. Поступак кодирања 
текста помоћу бројева може такође да буде јавно познат (ово још увек није шифровање, односно 
енкрипција). Након добијања поменутог низа бројева који представља полазни текст, сваки од тих 
бројева криптујемо помоћу кључа :math:`(n, e)` и декриптујемо помоћу кључа :math:`(n, d)`, на 
следећи начин.

**Криптовање:** Нека је :math:`M` један од бројева из низа који представља полазни текст. Криптована 
вредност :math:`C = F(M)` добија се као :math:`C = M^e \mod n`. У нашем примеру, ако је :math:`M=46`, 
добијамо криптовану вредност :math:`C = 46^7 \mod 143 = 84`

**Декриптовање:** Процес декриптовања је једнако једноставан као и криптовање. Претпоставимо да смо 
примили криптовани број :math:`C`. Полазни број :math:`M = F^{-1}(C)` добијамо као :math:`C^d \mod n`.
У нашем примеру, :math:`C^d \mod n = 84^{103} \mod 143 = 46`.

Следећи програм илуструје рад алгоритма RSA.

.. activecode:: rsa_program
    :include: rsa_javni_i_privatni_kljuc

    def kriptovano(M):
        return (M**e) % n

    def dekriptovano(C):
        return (C**d) % n

    M = 46
    C = kriptovano(M)
    M1 = dekriptovano(C)

    print('Порука  M =', M)
    print('Криптована вредност C =', C)
    print('Декриптована вредност M =', M1)



Напади на RSA криптосистем
''''''''''''''''''''''''''

Нападач би могао да покуша да на основу јавног кључа открије, тј. израчуна тајни кључ и тако 
разбије шифру. Пошто је број :math:`n` део јавног кључа, он је нападачу познат. Растављањем 
броја :math:`n` на просте чиниоце, нападач може да дође до простих бројева :math:`p` и :math:`q`,
а затим да одреди кључ :math:`d` на исти начин као што то ради и власник приватног кључа.

Ево како би тај постуапк изгледао:

.. activecode:: rsa_razbijanje

    def faktorizacija(n):
        faktori = []
        i = 2
        while i*i <= n:
            if n % i == 0:
                faktori.append(i)
                n = n // i
            else:
                i += 1

        if n > 1:
            faktori.append(n)

        return faktori
        
    # функција за дате a, b враћа d, x, y, такве да је ax+by = nzd(a,b)
    def prosireni_euklidov_algoritam(a, b):
        if (a == 0):
            d, x, y = b, 0, 1
        else:
            d, x1, y1 = prosireni_euklidov_algoritam(b % a, a)
            x, y = y1 - (b // a) * x1, x1

        return d, x, y
 
    # мултипликативни инверз од `a` по модулу `m`
    # (ради ако су `a` и `m` узајамно прости)
    def inverz(a, m):
        gcd, x, y = prosireni_euklidov_algoritam(a, m)
        # следећа наредба служи да би се добило 0 < x < m
        x = (x % m + m) % m 
        return x
 
    def kriptovano(M):
        return (M**e) % n

    def dekriptovano(C):
        return (C**d) % n

    n = 143
    e = 7
    C = 84
    faktori = faktorizacija(n)
    if len(faktori) == 2:
        p, q = faktori
        d = inverz(e, (p-1)*(q-1))

    M = dekriptovano(C)
    print('Декриптована вредност M =', M)

.. infonote::

    Видимо да полазећи само од јавног кључа :math:`(n, e)` и пресретнутог шифрата :math:`C`, нападач 
    **у принципу** може да израчуна приватни кључ :math:`(n, d)`, да декриптује шифрат и открије 
    поруку :math:`M`.

Сва безбедност криптосистема RSA је у томе што он у пракси користи много веће бројеве од ових у 
нашем примеру. Мали бројеви попут ових из примера би учинили криптосистем са таквим параметрима врло 
небезбедним. Ми смо користили мале бројеве само ради лакшег праћења рада алгоритма и његовог разумевања.

Функције ``prosireni_euklidov_algoritam``, ``inverz``, ``kriptovano`` и ``dekriptovano`` се извршавају 
прилично брзо чак и за огромне бројеве, у њима је број потребних операција сразмеран броју цифара броја 
на који се примењују. Једина спорија функција је ``faktorizacija``, број операција које су њој потребне 
је сразмеран са вредношћу :math:`\sqrt{n}`. Када би нападач користио поступак факторизације као у 
претходном програму, за број :math:`n` од 100 цифара би му на обичном рачунару требале милијарде година да 
нађе његове просте чиниоце. 

.. infonote::

    Безбедност алгоритма RSA се не заснива на пажљивом чувању неког тајног податка или поступка. 
    Напротив, видели смом да је познато како може да се израчуна приватни кључ. Дакле, изазов који се 
    поставља пред нападача је "само" проблем огромне количине рачунања. 

Током ових неколико деценија колико се алгоритам RSA користи, пронађени су разни начини да се алгоритам 
факторизације убрза. Због тога, чак ни бројеви са 100 цифара нису више довољно велики да би се 
криптовање базирано на њима сматрало безбедним. То не компромитује саму идеју алгоритма, али захтева 
од организатора криптосистема да користе све веће и веће бројеве. Да би се по данашњим стандардима 
поступак криптовања сматрао безбедним, потребно је да се бројеви :math:`p` и :math:`q` записују са 
по бар 1024 бита, што значи да имају преко 300 декадних цифара. При томе, ово чак није једини услов који 
треба да испуне :math:`p` и :math:`q`, да би нападачу било тешко (у пракси немогуће) да разбије шифру. 
Неки од додатних услова су да бројеви :math:`p` и :math:`q` не смеју да буду сувише близу један другом 
(треба да се по дужуни записа разликују за више десетина цифара), а важно је и да се ниједан од бројева 
:math:`p` и :math:`q` не користи у другим криптосистемима заснованим на алгоритму RSA. 

Последњи услов може лако да се образложи. Претпоставимо да смо изабрали неке огромне просте бројеве 
:math:`p_1` и :math:`q_1`, а неко други бројеве :math:`p_2` и :math:`q_2`. Ако би било :math:`p_1 = p_2`, 
тада би нападач, знајући бројеве :math:`n_1` и :math:`n_2`, могао брзо да нађе :math:`nzd(n_1, n_2) = p_1 = p_2`, 
а то би му било довољно да факторише и :math:`n_1` и :math:`n_2` и да разбије обе шифре.

~~~~

Видимо да је избор простих бројева који се користе у алгоритму RSA прилично сложен проблем. Исто важи 
и за избор јавног кључа, па и за начин представљања оригиналних података бројевима, који ће даље бити 
криптовани алгоритмом RSA. На ову тему постоји велики број научних радова, што није ни чудо због изузетног 
практичног значаја који овај алгоритам и даље има. Из свега што је познато о алгоритму RSA, може се 
закључити да је овај поступак криптовања у основи поуздан, али да је у многим случајевима имплементиран 
на несигуран начин, тј. са недовољно поузданим вредностима параметара.

Мада је алгоритам RSA у међувремену инпсирисао откриће других, сличних али напреднијих алгоритама, 
он је још увек најпопуларнији криптосистем са јавним кључем.
